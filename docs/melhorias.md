  ---
  üéØ Recomenda√ß√£o: Arquitetura Evolucion√°ria

  Estrat√©gia: "Refatorar Progressivamente, N√£o Reescrever"

  N√£o recomendo reescrever tudo agora. Em vez disso, introduza         
  camadas gradualmente onde a dor √© maior:

  Fase 1: Adicionar Service Layer (Prioridade ALTA)

  Quando usar Services:
  - ‚úÖ L√≥gica de neg√≥cio com m√∫ltiplos steps
  - ‚úÖ Opera√ß√µes que envolvem m√∫ltiplos models
  - ‚úÖ Transa√ß√µes complexas
  - ‚úÖ Side effects (emails, webhooks, provisioning)

  Exemplo de Refatora√ß√£o:

  // ‚ùå ANTES: L√≥gica no Model
  // src/server/infra/models/TenantApplication.js
  static async grantLicense(licenseData) {
    // 224 linhas de valida√ß√£o + insert + provisioning + logs
  }

  // ‚úÖ DEPOIS: Service Layer
  // src/server/services/LicenseService.js
  class LicenseService {
    async grantLicense(tenantId, applicationId, options) {
      // 1. Valida√ß√µes
      await this.validateLicenseData(tenantId, applicationId,
  options)

      // 2. Business logic
      const license = await TenantApplication.create({
        tenantId,
        applicationId,
        ...options
      })

      // 3. Side effects (provisioning)
      await this.provisionApplicationSchema(tenantId,
  applicationId)

      // 4. Audit/Logging
      await this.logLicenseGrant(license)

      return license
    }

    private async validateLicenseData(tenantId, applicationId,
  options) {
      const application = await Application.findById(applicationId)    
      if (!application) throw new ApplicationNotFoundError()

      const existing = await
  TenantApplication.findByTenantAndApplication(tenantId,
  applicationId)
      if (existing) throw new Error('License already exists')
    }

    private async provisionApplicationSchema(tenantId,
  applicationId) {
      const tenant = await Tenant.findById(tenantId)
      const application = await Application.findById(applicationId)    

      if (application.slug === 'tq') {
        const client = await database.getClient()
        try {
          await provisionTQAppSchema(client, tenant.schemaName,        
  tenant.timezone)
        } finally {
          client.release()
        }
      }
    }

    private async logLicenseGrant(license) {
      console.log('‚úÖ License granted:', license.id)
    }
  }

  // Route agora fica simples:
  // src/server/api/internal/routes/tenant-applications.js
  router.post('/', async (req, res) => {
    try {
      const licenseService = new LicenseService()
      const license = await licenseService.grantLicense(
        req.body.tenantId,
        req.body.applicationId,
        req.body
      )

      res.status(201).json({ data: license.toJSON() })
    } catch (error) {
      handleError(res, error)
    }
  })

  Benef√≠cios:
  - ‚úÖ Route handler agora tem 10 linhas (era 50+)
  - ‚úÖ L√≥gica de neg√≥cio test√°vel sem Express
  - ‚úÖ Service pode ser reutilizado (API, CLI, background jobs)        
  - ‚úÖ Model volta a ser "s√≥ dados + queries simples"

  ---
  Fase 2: Adicionar Input Validation Layer (Prioridade M√âDIA)

  Use Zod ou Joi para valida√ß√£o declarativa:

  // src/server/api/tq/validation/quote.schema.js
  const { z } = require('zod')

  const createQuoteSchema = z.object({
    sessionId: z.string().uuid(),
    content: z.string().optional(),
    status: z.enum(['draft', 'sent', 'approved',
  'rejected']).default('draft'),
    expiresAt: z.string().datetime().optional()
  })

  // Middleware de valida√ß√£o
  const validateBody = (schema) => (req, res, next) => {
    try {
      req.validatedBody = schema.parse(req.body)
      next()
    } catch (error) {
      res.status(400).json({
        error: 'Validation Error',
        details: error.errors
      })
    }
  }

  // Route usa middleware
  router.post('/', validateBody(createQuoteSchema), async (req,        
  res) => {
    const quote = await Quote.create(req.validatedBody,
  req.tenant.schema)
    res.status(201).json({ data: quote.toJSON() })
  })

  ---
  Fase 3: Controllers Opcionais (Prioridade BAIXA)

  S√≥ adicione se:
  - Routes come√ßarem a ter muita l√≥gica de formata√ß√£o de resposta      
  - Precisar de m√∫ltiplos formatos de output (JSON, XML, CSV)
  - Time crescer e precisar de separa√ß√£o clara de responsabilidades    

  // src/server/api/tq/controllers/QuoteController.js
  class QuoteController {
    async create(req, res) {
      const { sessionId, content, status } = req.validatedBody
      const schema = req.tenant.schema

      const quote = await Quote.create({ sessionId, content, status    
   }, schema)

      return this.sendCreated(res, quote.toJSON(), 'QUOTE_CREATED')    
    }

    sendCreated(res, data, code) {
      res.status(201).json({
        data,
        meta: { code, message: 'Created successfully' }
      })
    }
  }

  // Route vira uma linha
  router.post('/', validateBody(createQuoteSchema), (req, res) =>      
    new QuoteController().create(req, res)
  )

  ---
  üìä Arquitetura Recomendada para Este Projeto

  Estrutura Proposta (Gradual)

  src/server/
  ‚îú‚îÄ‚îÄ api/
  ‚îÇ   ‚îú‚îÄ‚îÄ tq/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/           # Express routes (thin handlers)       
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation/       # Zod schemas
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
  ‚îÇ   ‚îî‚îÄ‚îÄ public/
  ‚îÇ       ‚îî‚îÄ‚îÄ routes/
  ‚îú‚îÄ‚îÄ services/                 # ‚≠ê NOVO: Business logic
  ‚îÇ   ‚îú‚îÄ‚îÄ LicenseService.js
  ‚îÇ   ‚îú‚îÄ‚îÄ QuoteService.js
  ‚îÇ   ‚îî‚îÄ‚îÄ PublicQuoteService.js
  ‚îú‚îÄ‚îÄ infra/
  ‚îÇ   ‚îú‚îÄ‚îÄ models/              # Data access only (queries)
  ‚îÇ   ‚îú‚îÄ‚îÄ middleware/
  ‚îÇ   ‚îú‚îÄ‚îÄ provisioners/
  ‚îÇ   ‚îî‚îÄ‚îÄ db/
  ‚îî‚îÄ‚îÄ shared/
      ‚îî‚îÄ‚îÄ errors/              # Custom error classes

  Responsabilidades Claras

  | Camada       | Responsabilidade                          |
  Exemplo                                            |
  |--------------|-------------------------------------------|-----    
  -----------------------------------------------|
  | Routes       | HTTP layer (req/res), routing, middleware |
  Validar headers, chamar service, formatar response |
  | Services     | Business logic, orchestration             |
  Validar regras, coordenar models, side effects     |
  | Models       | Data access, queries simples              | CRUD    
   no banco, relacionamentos                     |
  | Provisioners | Schema setup, migrations                  |
  Criar tabelas, √≠ndices                             |

  ---
  üé¨ Plano de A√ß√£o para Public Quote Pages

  Op√ß√£o A: Seguir Padr√£o Atual (R√°pido, T√©cnico Debt)

  // Routes fazem tudo diretamente
  router.post('/tq/public-quotes', async (req, res) => {
    // Valida√ß√£o inline
    // Chamada direta ao Model
    // Resposta inline
  })

  Vantagens: R√°pido, consistente com codebase atualDesvantagens:       
  Adiciona mais debt t√©cnico

  ---
  Op√ß√£o B: Introduzir Service Layer (Recomendado)

  // src/server/services/PublicQuoteService.js
  class PublicQuoteService {
    async publishQuote(quoteId, options, schema) {
      // 1. Validar quote existe
      const quote = await Quote.findById(quoteId, schema, true,        
  true)

      // 2. Criar link p√∫blico
      const publicQuote = await PublicQuote.create({
        quoteId,
        password: options.password,
        expiresAt: options.expiresAt || this.getDefaultExpiry(),       
        puckSchema: options.puckSchema
      }, schema)

      // 3. Log/Audit
      await this.logPublicQuoteCreation(publicQuote)

      return publicQuote
    }

    async viewPublicQuote(tenantSlug, token, password) {
      // 1. Resolver tenant
      const tenant = await this.resolveTenant(tenantSlug)

      // 2. Validar token + senha
      const publicQuote = await this.validateAccess(token,
  password, tenant.schema)

      // 3. Incrementar views
      await publicQuote.incrementViews(tenant.schema)

      // 4. Buscar dados completos
      const quote = await Quote.findById(publicQuote.quoteId,
  tenant.schema, true, true)
      const branding = await TenantBranding.findByTenant(tenant.id)    

      return { quote, branding, publicQuote }
    }
  }

  // Route agora √© limpa:
  router.post('/tq/public-quotes',
  validateBody(publishQuoteSchema), async (req, res) => {
    const service = new PublicQuoteService()
    const publicQuote = await service.publishQuote(
      req.body.quoteId,
      req.body,
      req.tenant.schema
    )

    res.status(201).json({ data: publicQuote.toJSON() })
  })

  Vantagens:‚úÖ L√≥gica test√°vel‚úÖ Reutiliz√°vel‚úÖ Prepara o projeto      
  para escalar‚úÖ Consistente com projetos enterprise

  Desvantagens:‚ö†Ô∏è Mais c√≥digo inicial‚ö†Ô∏è Time precisa aprender novo     
  padr√£o
 ---
  üéØ Recomenda√ß√£o: Arquitetura Evolucion√°ria

  Estrat√©gia: "Refatorar Progressivamente, N√£o Reescrever"

  N√£o recomendo reescrever tudo agora. Em vez disso, introduza         
  camadas gradualmente onde a dor √© maior:

  Fase 1: Adicionar Service Layer (Prioridade ALTA)

  Quando usar Services:
  - ‚úÖ L√≥gica de neg√≥cio com m√∫ltiplos steps
  - ‚úÖ Opera√ß√µes que envolvem m√∫ltiplos models
  - ‚úÖ Transa√ß√µes complexas
  - ‚úÖ Side effects (emails, webhooks, provisioning)

  Exemplo de Refatora√ß√£o:

  // ‚ùå ANTES: L√≥gica no Model
  // src/server/infra/models/TenantApplication.js
  static async grantLicense(licenseData) {
    // 224 linhas de valida√ß√£o + insert + provisioning + logs
  }

  // ‚úÖ DEPOIS: Service Layer
  // src/server/services/LicenseService.js
  class LicenseService {
    async grantLicense(tenantId, applicationId, options) {
      // 1. Valida√ß√µes
      await this.validateLicenseData(tenantId, applicationId,
  options)

      // 2. Business logic
      const license = await TenantApplication.create({
        tenantId,
        applicationId,
        ...options
      })

      // 3. Side effects (provisioning)
      await this.provisionApplicationSchema(tenantId,
  applicationId)

      // 4. Audit/Logging
      await this.logLicenseGrant(license)

      return license
    }

    private async validateLicenseData(tenantId, applicationId,
  options) {
      const application = await Application.findById(applicationId)    
      if (!application) throw new ApplicationNotFoundError()

      const existing = await
  TenantApplication.findByTenantAndApplication(tenantId,
  applicationId)
      if (existing) throw new Error('License already exists')
    }

    private async provisionApplicationSchema(tenantId,
  applicationId) {
      const tenant = await Tenant.findById(tenantId)
      const application = await Application.findById(applicationId)    

      if (application.slug === 'tq') {
        const client = await database.getClient()
        try {
          await provisionTQAppSchema(client, tenant.schemaName,        
  tenant.timezone)
        } finally {
          client.release()
        }
      }
    }

    private async logLicenseGrant(license) {
      console.log('‚úÖ License granted:', license.id)
    }
  }

  // Route agora fica simples:
  // src/server/api/internal/routes/tenant-applications.js
  router.post('/', async (req, res) => {
    try {
      const licenseService = new LicenseService()
      const license = await licenseService.grantLicense(
        req.body.tenantId,
        req.body.applicationId,
        req.body
      )

      res.status(201).json({ data: license.toJSON() })
    } catch (error) {
      handleError(res, error)
    }
  })

  Benef√≠cios:
  - ‚úÖ Route handler agora tem 10 linhas (era 50+)
  - ‚úÖ L√≥gica de neg√≥cio test√°vel sem Express
  - ‚úÖ Service pode ser reutilizado (API, CLI, background jobs)        
  - ‚úÖ Model volta a ser "s√≥ dados + queries simples"

  ---
  Fase 2: Adicionar Input Validation Layer (Prioridade M√âDIA)

  Use Zod ou Joi para valida√ß√£o declarativa:

  // src/server/api/tq/validation/quote.schema.js
  const { z } = require('zod')

  const createQuoteSchema = z.object({
    sessionId: z.string().uuid(),
    content: z.string().optional(),
    status: z.enum(['draft', 'sent', 'approved',
  'rejected']).default('draft'),
    expiresAt: z.string().datetime().optional()
  })

  // Middleware de valida√ß√£o
  const validateBody = (schema) => (req, res, next) => {
    try {
      req.validatedBody = schema.parse(req.body)
      next()
    } catch (error) {
      res.status(400).json({
        error: 'Validation Error',
        details: error.errors
      })
    }
  }

  // Route usa middleware
  router.post('/', validateBody(createQuoteSchema), async (req,        
  res) => {
    const quote = await Quote.create(req.validatedBody,
  req.tenant.schema)
    res.status(201).json({ data: quote.toJSON() })
  })

  ---
  Fase 3: Controllers Opcionais (Prioridade BAIXA)

  S√≥ adicione se:
  - Routes come√ßarem a ter muita l√≥gica de formata√ß√£o de resposta      
  - Precisar de m√∫ltiplos formatos de output (JSON, XML, CSV)
  - Time crescer e precisar de separa√ß√£o clara de responsabilidades    

  // src/server/api/tq/controllers/QuoteController.js
  class QuoteController {
    async create(req, res) {
      const { sessionId, content, status } = req.validatedBody
      const schema = req.tenant.schema

      const quote = await Quote.create({ sessionId, content, status    
   }, schema)

      return this.sendCreated(res, quote.toJSON(), 'QUOTE_CREATED')    
    }

    sendCreated(res, data, code) {
      res.status(201).json({
        data,
        meta: { code, message: 'Created successfully' }
      })
    }
  }

  // Route vira uma linha
  router.post('/', validateBody(createQuoteSchema), (req, res) =>      
    new QuoteController().create(req, res)
  )

  ---
  üìä Arquitetura Recomendada para Este Projeto

  Estrutura Proposta (Gradual)

  src/server/
  ‚îú‚îÄ‚îÄ api/
  ‚îÇ   ‚îú‚îÄ‚îÄ tq/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/           # Express routes (thin handlers)       
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation/       # Zod schemas
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
  ‚îÇ   ‚îî‚îÄ‚îÄ public/
  ‚îÇ       ‚îî‚îÄ‚îÄ routes/
  ‚îú‚îÄ‚îÄ services/                 # ‚≠ê NOVO: Business logic
  ‚îÇ   ‚îú‚îÄ‚îÄ LicenseService.js
  ‚îÇ   ‚îú‚îÄ‚îÄ QuoteService.js
  ‚îÇ   ‚îî‚îÄ‚îÄ PublicQuoteService.js
  ‚îú‚îÄ‚îÄ infra/
  ‚îÇ   ‚îú‚îÄ‚îÄ models/              # Data access only (queries)
  ‚îÇ   ‚îú‚îÄ‚îÄ middleware/
  ‚îÇ   ‚îú‚îÄ‚îÄ provisioners/
  ‚îÇ   ‚îî‚îÄ‚îÄ db/
  ‚îî‚îÄ‚îÄ shared/
      ‚îî‚îÄ‚îÄ errors/              # Custom error classes

  Responsabilidades Claras

  | Camada       | Responsabilidade                          |
  Exemplo                                            |
  |--------------|-------------------------------------------|-----    
  -----------------------------------------------|
  | Routes       | HTTP layer (req/res), routing, middleware |
  Validar headers, chamar service, formatar response |
  | Services     | Business logic, orchestration             |
  Validar regras, coordenar models, side effects     |
  | Models       | Data access, queries simples              | CRUD    
   no banco, relacionamentos                     |
  | Provisioners | Schema setup, migrations                  |
  Criar tabelas, √≠ndices                             |

  ---
  üé¨ Plano de A√ß√£o para Public Quote Pages

  Op√ß√£o A: Seguir Padr√£o Atual (R√°pido, T√©cnico Debt)

  // Routes fazem tudo diretamente
  router.post('/tq/public-quotes', async (req, res) => {
    // Valida√ß√£o inline
    // Chamada direta ao Model
    // Resposta inline
  })

  Vantagens: R√°pido, consistente com codebase atualDesvantagens:       
  Adiciona mais debt t√©cnico

  ---
  Op√ß√£o B: Introduzir Service Layer (Recomendado)

  // src/server/services/PublicQuoteService.js
  class PublicQuoteService {
    async publishQuote(quoteId, options, schema) {
      // 1. Validar quote existe
      const quote = await Quote.findById(quoteId, schema, true,        
  true)

      // 2. Criar link p√∫blico
      const publicQuote = await PublicQuote.create({
        quoteId,
        password: options.password,
        expiresAt: options.expiresAt || this.getDefaultExpiry(),       
        puckSchema: options.puckSchema
      }, schema)

      // 3. Log/Audit
      await this.logPublicQuoteCreation(publicQuote)

      return publicQuote
    }

    async viewPublicQuote(tenantSlug, token, password) {
      // 1. Resolver tenant
      const tenant = await this.resolveTenant(tenantSlug)

      // 2. Validar token + senha
      const publicQuote = await this.validateAccess(token,
  password, tenant.schema)

      // 3. Incrementar views
      await publicQuote.incrementViews(tenant.schema)

      // 4. Buscar dados completos
      const quote = await Quote.findById(publicQuote.quoteId,
  tenant.schema, true, true)
      const branding = await TenantBranding.findByTenant(tenant.id)    

      return { quote, branding, publicQuote }
    }
  }

  // Route agora √© limpa:
  router.post('/tq/public-quotes',
  validateBody(publishQuoteSchema), async (req, res) => {
    const service = new PublicQuoteService()
    const publicQuote = await service.publishQuote(
      req.body.quoteId,
      req.body,
      req.tenant.schema
    )

    res.status(201).json({ data: publicQuote.toJSON() })
  })

  Vantagens:‚úÖ L√≥gica test√°vel‚úÖ Reutiliz√°vel‚úÖ Prepara o projeto      
  para escalar‚úÖ Consistente com projetos enterprise

  Desvantagens:‚ö†Ô∏è Mais c√≥digo inicial‚ö†Ô∏è Time precisa aprender novo     
  padr√£o

    üìä Compara√ß√£o: Com vs Sem Service Layer

  | Aspecto          | Sem Service Layer (Atual)      | Com Service    
   Layer      |
  |------------------|--------------------------------|------------    
  ------------|
  | Linhas de c√≥digo | ~800                           | ~1200
              |
  | Arquivos         | 8                              | 12
              |
  | Complexidade     | Baixa                          | M√©dia
              |
  | Testabilidade    | Boa (integration tests)        | Excelente      
  (unit tests) |
  | Velocidade dev   | ‚ö° R√°pida                       | üê¢ Mais       
  lenta          |
  | Manuten√ß√£o       | F√°cil (time conhece)           | Requer
  onboarding      |
  | Escalabilidade   | Suficiente para 100-1000 users | Melhor para    
   10k+ users |
  | Consist√™ncia     | ‚úÖ Consistente com codebase     | ‚ùå Novo       
  padr√£o          |

  Veredito: Para este projeto, Sem Service Layer vence.

  CONFIGURATIONS ENTITIES

    Op√ß√£o 2: Tabelas Especializadas por Dom√≠nio

  -- Branding (visual identity)
  CREATE TABLE tenant_branding (
    id SERIAL PRIMARY KEY,
    tenant_id_fk INTEGER NOT NULL REFERENCES tenants(id) UNIQUE,       
    primary_color VARCHAR(7) DEFAULT '#B725B7',
    secondary_color VARCHAR(7) DEFAULT '#E91E63',
    tertiary_color VARCHAR(7) DEFAULT '#5ED6CE',
    logo_url TEXT,
    favicon_url TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
  );

  -- Email settings
  CREATE TABLE tenant_email_settings (
    id SERIAL PRIMARY KEY,
    tenant_id_fk INTEGER NOT NULL REFERENCES tenants(id) UNIQUE,       
    from_name VARCHAR(255),
    from_email VARCHAR(255),
    reply_to VARCHAR(255),
    smtp_host VARCHAR(255),
    smtp_port INTEGER,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
  );

  -- Workflow preferences
  CREATE TABLE tenant_workflow_settings (
    id SERIAL PRIMARY KEY,
    tenant_id_fk INTEGER NOT NULL REFERENCES tenants(id) UNIQUE,       
    auto_approve_quotes BOOLEAN DEFAULT false,
    default_quote_expiry_days INTEGER DEFAULT 30,
    require_approval_above_amount NUMERIC(10,2),
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
  );

  -- Integrations (sensitive data)
  CREATE TABLE tenant_integrations (
    id SERIAL PRIMARY KEY,
    tenant_id_fk INTEGER NOT NULL REFERENCES tenants(id) UNIQUE,       
    stripe_api_key_encrypted TEXT,
    twilio_account_sid_encrypted TEXT,
    aws_s3_bucket VARCHAR(255),
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
  );

  ‚úÖ Vantagens:
  - Schema fortemente tipado (valida√ß√£o no banco)
  - Queries simples e r√°pidas
  - JOINs eficientes
  - C√≥digo type-safe (branding.primaryColor)
  - F√°cil aplicar constraints (CHECK, NOT NULL, etc)
  - Clara separa√ß√£o de concerns
  - Migrations documentam evolu√ß√£o

  ‚ùå Desvantagens:
  - Precisa migration para cada novo dom√≠nio
  - Mais tabelas no banco
  - Menos "flex√≠vel" (mas isso √© bom!)

  ----

 Excelente reflex√£o! ü§î Vamos analisar a arquitetura de autentica√ß√£o atual e o que faz sentido para o cen√°rio de **m√∫ltiplos dom√≠nios**.

---

## üîç Situa√ß√£o Atual (Como Funciona)

### **1. Estrutura de Token JWT**
```javascript
{
  userId: 2,
  tenantId: 2,
  email: "user@example.com",
  role: "admin",
  allowedApps: ["hub", "tq"], // Apps que o usu√°rio pode acessar
  userType: { id: 3, slug: "admin" }
}
```

### **2. Fluxo Atual**
```
1. User ‚Üí Login no HUB ‚Üí Token JWT (localStorage)
2. User clica em "TQ" no HUB ‚Üí window.open(TQ_URL)
3. TQ abre ‚Üí ??? (Como recebe o token do HUB?)
4. TQ tem rota /auth/login independente ‚Üí Pode criar NOVO token
```

### **3. Problema Identificado** ‚ö†Ô∏è
- **Dom√≠nios separados** (`hub.simplia.com`, `tq.simplia.com`)
- **localStorage n√£o compartilha** entre dom√≠nios
- **Cookies n√£o compartilham** entre dom√≠nios diferentes
- **Sess√µes independentes** ‚Üí N√£o √© verdadeiro SSO

---

## üéØ O Que Faz Sentido?

Para m√∫ltiplos dom√≠nios, voc√™ tem **3 op√ß√µes arquiteturais**:

---

## Op√ß√£o 1: **True SSO (OAuth2/OIDC)** ‚úÖ Recomendado para Produ√ß√£o

### **Arquitetura:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          auth.simplia.com (Central)          ‚îÇ
‚îÇ  - √önico ponto de autentica√ß√£o               ‚îÇ
‚îÇ  - Gerencia sess√µes centralizadas            ‚îÇ
‚îÇ  - Emite tokens para apps autorizados        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚Üì              ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ hub.simplia  ‚îÇ   ‚îÇ tq.simplia   ‚îÇ
    ‚îÇ (Client App) ‚îÇ   ‚îÇ (Client App) ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### **Fluxo:**
1. **User acessa hub.simplia** (n√£o autenticado)
2. **Hub redireciona** ‚Üí `auth.simplia/login?redirect_uri=hub.simplia&client_id=hub`
3. **User faz login** no Auth Server
4. **Auth Server cria sess√£o** (cookie em `.simplia.com`)
5. **Auth Server redireciona** ‚Üí `hub.simplia?code=ABC123`
6. **Hub troca code** por token JWT com backend
7. **User clica em TQ** no Hub
8. **TQ verifica sess√£o** ‚Üí Cookie `.simplia.com` existe?
   - ‚úÖ **Se sim:** Silent auth (renova token automaticamente)
   - ‚ùå **Se n√£o:** Redireciona para auth.simplia

### **Single Logout:**
```javascript
// User faz logout no TQ
POST auth.simplia/logout ‚Üí Invalida sess√£o central
// Hub detecta logout automaticamente (cookie inv√°lido)
```

### **Vantagens:**
- ‚úÖ Sess√£o √∫nica entre todos os apps
- ‚úÖ Single Logout funciona
- ‚úÖ Escal√°vel (adicionar novos apps √© f√°cil)
- ‚úÖ Seguro (tokens de curta dura√ß√£o, refresh tokens)
- ‚úÖ Padr√£o da ind√∫stria (Google, Microsoft, Auth0)

### **Desvantagens:**
- ‚ùå Complexidade m√©dia de implementa√ß√£o
- ‚ùå Requer servidor de autentica√ß√£o dedicado

---

## Op√ß√£o 2: **Shared Cookie (Subdomain)** üîÑ Mais Simples

### **Arquitetura:**
```javascript
// Cookie compartilhado em .simplia.com
document.cookie = "auth_token=JWT; domain=.simplia.com; secure; httpOnly";
```

### **Fluxo:**
1. **User faz login no Hub** ‚Üí Cookie em `.simplia.com`
2. **Hub e TQ compartilham** mesmo cookie
3. **User acessa TQ** ‚Üí Cookie j√° existe ‚Üí Auto-autenticado
4. **Logout em qualquer app** ‚Üí Deleta cookie ‚Üí Afeta todos

### **Vantagens:**
- ‚úÖ Implementa√ß√£o simples
- ‚úÖ Sess√£o compartilhada automaticamente
- ‚úÖ Single logout funciona

### **Desvantagens:**
- ‚ùå **S√≥ funciona em subdom√≠nios** (`.simplia.com`)
- ‚ùå N√£o funciona se hub e TQ tiverem **dom√≠nios completamente diferentes**
- ‚ùå Menos flex√≠vel que OAuth2

---

## Op√ß√£o 3: **Token via Postmessage** üì® Solu√ß√£o Tempor√°ria

### **Arquitetura:**
```javascript
// No Hub
window.open('https://tq.simplia.com/?auth_flow=sso');

// No TQ (ao abrir)
window.addEventListener('message', (event) => {
  if (event.origin === 'https://hub.simplia.com') {
    const token = event.data.token;
    localStorage.setItem('auth_token', token);
  }
});

// Hub envia token
tqWindow.postMessage({ token: authToken }, 'https://tq.simplia.com');
```

### **Vantagens:**
- ‚úÖ Funciona entre dom√≠nios diferentes
- ‚úÖ Implementa√ß√£o r√°pida

### **Desvantagens:**
- ‚ùå **Inseguro** (token exposto via postMessage)
- ‚ùå Sess√µes ainda s√£o independentes (logout n√£o sincroniza)
- ‚ùå N√£o √© escal√°vel
- ‚ùå **N√£o recomendado para produ√ß√£o**

---

## üèÜ Recomenda√ß√£o

Para o cen√°rio de **m√∫ltiplos dom√≠nios** (`hub.simplia.com`, `tq.simplia.com`, etc.), recomendo:

### **Fase 1 (Curto Prazo): Shared Cookie**
Se todos os apps ser√£o **subdom√≠nios** de `simplia.com`:
- ‚úÖ Use cookie compartilhado (`.simplia.com`)
- ‚úÖ Sess√£o √∫nica autom√°tica
- ‚úÖ Single logout funciona
- ‚úÖ Implementa√ß√£o em 1-2 dias

### **Fase 2 (Longo Prazo): True SSO**
Se apps ter√£o **dom√≠nios diferentes** OU voc√™ quer **arquitetura profissional**:
- ‚úÖ Implemente OAuth2/OIDC
- ‚úÖ Auth server central (`auth.simplia.com`)
- ‚úÖ Authorization Code Flow
- ‚úÖ Refresh tokens com rota√ß√£o
- ‚úÖ Escal√°vel para dezenas de apps

---

## üí° Pergunta para Voc√™

**Cen√°rio de dom√≠nios:**
1. Todos os apps ser√£o subdom√≠nios (`hub.simplia.com`, `tq.simplia.com`)? ‚Üí **Op√ß√£o 2 (Cookie)**
2. Apps ter√£o dom√≠nios diferentes (`hub.app`, `tq.io`)? ‚Üí **Op√ß√£o 1 (SSO)**
3. Quantos apps voc√™ planeja ter (2, 5, 10+)?

**Prioridade:**
- Precisa funcionar **agora** (MVP)? ‚Üí **Op√ß√£o 2**
- Pode investir 1-2 semanas? ‚Üí **Op√ß√£o 1**

---

## üìä Compara√ß√£o R√°pida

| Crit√©rio | Shared Cookie | True SSO | PostMessage |
|----------|---------------|----------|-------------|
| **Complexidade** | üü¢ Baixa | üü° M√©dia | üü¢ Baixa |
| **Seguran√ßa** | üü¢ Boa | üü¢ Excelente | üî¥ Fraca |
| **Multi-dom√≠nio** | üî¥ N√£o | üü¢ Sim | üü¢ Sim |
| **Single Logout** | üü¢ Sim | üü¢ Sim | üî¥ N√£o |
| **Escalabilidade** | üü° M√©dia | üü¢ Alta | üî¥ Baixa |
| **Tempo Impl** | 1-2 dias | 1-2 semanas | 1 dia |

---

**O que voc√™ prefere?** Me diga o cen√°rio de dom√≠nios e posso detalhar a implementa√ß√£o! üöÄ