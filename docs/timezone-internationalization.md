# Timezone & Internationalization (i18n) - Complete Implementation Guide

## üìã Table of Contents

1. [Problem Statement](#problem-statement)
2. [Solution Overview](#solution-overview)
3. [Architecture](#architecture)
4. [Implementation Details](#implementation-details)
5. [Database Layer](#database-layer)
6. [Backend Layer](#backend-layer)
7. [Frontend Layer](#frontend-layer)
8. [Testing & Verification](#testing--verification)
9. [Troubleshooting](#troubleshooting)
10. [Files Reference](#files-reference)

---

## üéØ Problem Statement

### Business Requirements

**Multi-Tenant Timezone Support:**
- Tenant in **Brisbane, Australia** must see timestamps in Brisbane timezone (UTC+10)
- Tenant in **S√£o Paulo, Brazil** must see timestamps in S√£o Paulo timezone (UTC-3)
- Same timestamp must display correctly in each tenant's local timezone

**Multi-Language Support:**
- **Brazilian tenants** (timezones: America/Sao_Paulo, America/Bahia, etc.) ‚Üí **Portuguese (pt-BR)**
- **International tenants** (all other timezones) ‚Üí **English (en-US)**
- Only 2 languages supported as per requirement

### Technical Challenges

1. **Timestamp Ambiguity**: How do we know if "2025-10-09 20:24:48" is S√£o Paulo time or Brisbane time?
2. **Data Integrity**: How to prevent timezone data corruption across different servers?
3. **Multi-Tenant Isolation**: How to ensure each tenant sees their own timezone?
4. **Language Detection**: How to automatically select correct language based on tenant location?
5. **Consistency**: How to maintain uniform date formatting across TQ and Hub apps?

---

## üí° Solution Overview

### Core Principles

1. **UTC Everywhere in Database**: All timestamps stored in UTC (TIMESTAMPTZ type)
2. **Timezone Conversion on Display**: Convert UTC ‚Üí tenant timezone only in frontend
3. **Locale Auto-Detection**: Derive locale from timezone automatically
4. **Per-Tenant Configuration**: Each tenant has their own timezone and locale settings
5. **Centralized Formatting**: Single hook (`useDateFormatter`) for all date displays

### Language Rules

```javascript
// Brazil timezones ‚Üí pt-BR
'America/Sao_Paulo' ‚Üí 'pt-BR'
'America/Bahia' ‚Üí 'pt-BR'
'America/Fortaleza' ‚Üí 'pt-BR'
// ... 16 Brazil timezones total

// Everything else ‚Üí en-US
'Australia/Brisbane' ‚Üí 'en-US'
'Europe/London' ‚Üí 'en-US'
'America/New_York' ‚Üí 'en-US'
// ... all other timezones
```

### Date Format Examples

**Brazilian Tenant (pt-BR):**
- Short date: `10/01/2025` (DD/MM/YYYY)
- Long date: `10 de janeiro de 2025`
- Date time: `10/01/2025 15:30`
- Relative: `h√° 2 horas`

**International Tenant (en-US):**
- Short date: `1/10/2025` (M/D/YYYY)
- Long date: `January 10, 2025`
- Date time: `1/10/2025, 3:30 PM`
- Relative: `2 hours ago`

---

## üèóÔ∏è Architecture

### Data Flow Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    DATABASE (PostgreSQL)                         ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚úì ALL timestamps stored as TIMESTAMPTZ in UTC                  ‚îÇ
‚îÇ  ‚úì Pool connections forced to UTC timezone                      ‚îÇ
‚îÇ  ‚úì Example: 2025-10-09 23:24:48.503+00                         ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    BACKEND (Express.js)                          ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚úì JWT payload includes: timezone + locale                      ‚îÇ
‚îÇ  ‚úì Locale derived from timezone via localeMapping.js            ‚îÇ
‚îÇ  ‚úì Returns timestamps in ISO 8601 format (UTC)                  ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  JWT Payload Example:                                            ‚îÇ
‚îÇ  {                                                               ‚îÇ
‚îÇ    userId: 123,                                                  ‚îÇ
‚îÇ    tenantId: 456,                                                ‚îÇ
‚îÇ    timezone: "America/Sao_Paulo",                                ‚îÇ
‚îÇ    locale: "pt-BR"  // Auto-derived from timezone                ‚îÇ
‚îÇ  }                                                               ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    FRONTEND (React)                              ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚úì useDateFormatter hook reads timezone + locale from JWT        ‚îÇ
‚îÇ  ‚úì Intl.DateTimeFormat converts UTC ‚Üí tenant timezone           ‚îÇ
‚îÇ  ‚úì react-i18next translates UI based on locale                  ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  Display Examples:                                               ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  Brazil (pt-BR + America/Sao_Paulo):                             ‚îÇ
‚îÇ  ‚Üí "10/01/2025 20:24" (DD/MM/YYYY HH:mm)                        ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  Australia (en-US + Australia/Brisbane):                         ‚îÇ
‚îÇ  ‚Üí "1/10/2025, 9:24 AM" (M/D/YYYY h:mm A)                       ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Timezone Storage Strategy

**PostgreSQL TIMESTAMPTZ Behavior:**

```sql
-- What happens when you INSERT:
INSERT INTO patient (created_at) VALUES (now());
-- ‚úì Stores internally: 2025-10-09 23:24:48 UTC (always UTC on disk)

-- What happens when you SELECT with different timezones:
SET TIME ZONE 'America/Sao_Paulo';
SELECT created_at FROM patient;
-- Shows: 2025-10-09 20:24:48.503 -0300 (display format only)

SET TIME ZONE 'Australia/Brisbane';
SELECT created_at FROM patient;
-- Shows: 2025-10-10 09:24:48.503 +1000 (next day!)

SET TIME ZONE 'UTC';
SELECT created_at FROM patient;
-- Shows: 2025-10-09 23:24:48.503 +0000 (original UTC)
```

**Key Point:** The `-0300` or `+1000` you see is just display formatting by PostgreSQL. The actual data on disk is ALWAYS in UTC.

---

## üîß Implementation Details

### Phase 1: Database Layer (UTC Storage)

**Problem Discovered:**
- Pool connections were NOT setting timezone to UTC
- Each query got different connection from pool without timezone configured
- Server's default timezone (S√£o Paulo -0300) was being used

**Solution:**

```javascript
// src/server/infra/db/database.js

class Database {
  constructor() {
    this.pool = new Pool({
      // ... connection config
    })

    this.setupPoolEvents() // NEW: Configure all connections
  }

  setupPoolEvents() {
    // ‚úÖ CRITICAL: Force UTC on ALL pool connections
    this.pool.on('connect', async (client) => {
      await client.query("SET TIME ZONE 'UTC'")
      console.log('Database client connected with UTC timezone')
    })

    this.pool.on('error', (err) => {
      console.error('Database pool error:', err)
    })
  }
}
```

**Docker Configuration:**

```yaml
# docker-compose.yml

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: simplia_paas
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: 1234
      PGTZ: UTC              # PostgreSQL timezone
      TZ: UTC                # Container timezone
```

**Verification Query:**

```sql
-- Check if data is stored in UTC
SELECT
  timezone,
  created_at,
  created_at AT TIME ZONE 'UTC' AS stored_utc,
  created_at AT TIME ZONE timezone AS tenant_local
FROM tenants
JOIN patient ON true
LIMIT 1;

-- Example result:
-- timezone: 'America/Sao_Paulo'
-- created_at: 2025-10-10 00:26:14.093-03
-- stored_utc: 2025-10-10 03:26:14.093 (3 hours ahead = UTC)
-- tenant_local: 2025-10-10 00:26:14.093
```

### Phase 2: Locale Derivation from Timezone

**Problem Discovered:**
- JWT was returning `locale: "en-US"` even for Brazilian tenants
- Root cause: Incorrect relative path in require statement

**Before (BROKEN):**

```javascript
// src/shared/types/user.js
const { getLocaleFromTimezone } = require('../server/infra/utils/localeMapping')
// ‚ùå Wrong path! File is in src/shared/types/, so ../server/ doesn't work
```

**After (FIXED):**

```javascript
// src/shared/types/user.js

function createJwtPayload(user, tenant, allowedApps = [], userType = null) {
  // ... validation

  // ‚úÖ Derive locale from timezone
  let locale = 'en-US' // Default
  if (tenant.timezone) {
    try {
      const { getLocaleFromTimezone } = require('../../server/infra/utils/localeMapping')
      locale = getLocaleFromTimezone(tenant.timezone)
      console.log(`[JWT] Derived locale '${locale}' from timezone '${tenant.timezone}'`)
    } catch (error) {
      console.warn('[JWT] Failed to derive locale, using default en-US:', error.message)
    }
  }

  return {
    userId: user.id,
    tenantId: numericTenantId,
    email: user.email,
    name: user.name,
    role: user.role,
    schema: tenant.schema,
    timezone: tenant.timezone || 'America/Sao_Paulo',
    locale: locale, // ‚úÖ Correctly derived
    allowedApps: allowedApps,
    userType: userType ? { ... } : null,
    platformRole: user.role
  }
}
```

**Locale Mapping Logic:**

```javascript
// src/server/infra/utils/localeMapping.js

function getLocaleFromTimezone(timezone) {
  if (!timezone || typeof timezone !== 'string') {
    return 'pt-BR' // Default to Brazilian Portuguese
  }

  const tz = timezone.trim()

  // Brazil timezones ‚Üí pt-BR (16 timezones)
  if (
    tz === 'America/Sao_Paulo' ||
    tz === 'America/Bahia' ||
    tz === 'America/Fortaleza' ||
    tz === 'America/Recife' ||
    tz === 'America/Manaus' ||
    tz === 'America/Belem' ||
    tz === 'America/Rio_Branco' ||
    tz === 'America/Campo_Grande' ||
    tz === 'America/Cuiaba' ||
    tz === 'America/Boa_Vista' ||
    tz === 'America/Porto_Velho' ||
    tz === 'America/Eirunepe' ||
    tz === 'America/Maceio' ||
    tz === 'America/Araguaina' ||
    tz === 'America/Santarem' ||
    tz === 'America/Noronha'
  ) {
    return 'pt-BR'
  }

  // Everything else ‚Üí en-US (including Australia, USA, Europe, etc.)
  return 'en-US'
}

module.exports = {
  getLocaleFromTimezone,
  getLanguageFromLocale,
  isSupportedTimezone,
  getLocaleMetadata
}
```

### Phase 3: Frontend Date Formatting

**Problem Discovered:**
- Initial implementation used `require()` inside the hook to dynamically import auth stores
- This violated React's Rules of Hooks - hooks cannot be conditionally called
- `require()` was failing silently, returning `null` for both stores
- Result: All users saw default Brazilian timezone regardless of their actual tenant timezone

**Incorrect Approach (BROKEN):**

```typescript
// ‚ùå WRONG: Dynamic require() inside hook doesn't work
export function useDateFormatter() {
  let useTQAuthStore: any = null

  try {
    const tqAuth = require('@client/apps/tq/shared/store/auth')
    useTQAuthStore = tqAuth.useAuthStore  // ‚ùå Returns null
  } catch (e) {
    // Fails silently
  }

  // useTQAuthStore is always null!
  const timezone = useTQAuthStore ? useTQAuthStore(state => state.tenantTimezone) : undefined
  // ‚ùå Result: Always uses fallback 'America/Sao_Paulo'
}
```

**Correct Approach (FIXED):**

```typescript
// ‚úÖ CORRECT: Static import at module level
import { useAuthStore as useTQAuthStore } from '@client/apps/tq/shared/store/auth'

export function useDateFormatter() {
  // ‚úÖ Subscribe to Zustand store reactively
  // This follows React's Rules of Hooks - unconditional hook call
  const timezone = useTQAuthStore(state => state.tenantTimezone) || 'America/Sao_Paulo'
  const locale = useTQAuthStore(state => state.tenantLocale) || 'pt-BR'

  // ‚úÖ Hook will re-render when timezone/locale change in store
  return {
    formatShortDate: (date) => formatShortDateUtil(date, timezone, locale),
    formatLongDate: (date) => formatLongDateUtil(date, timezone, locale),
    formatTime: (date) => formatTimeUtil(date, timezone, locale),
    formatDateTime: (date) => formatDateTimeUtil(date, timezone, locale),
    formatRelativeTime: (date) => formatRelativeTimeUtil(date, timezone, locale),
    formatMonthYear: (date) => formatMonthYearUtil(date, timezone, locale),
    getNowInTimezone: () => getNowInTimezoneUtil(timezone),
    getTimezone: () => timezone,
    getLocale: () => locale
  }
}
```

**Why This Works:**

1. **Static Import**: `import` statement runs at module evaluation time (before React)
2. **Zustand Hook**: `useTQAuthStore(selector)` is called unconditionally (follows Rules of Hooks)
3. **Reactive**: When `tenantTimezone` or `tenantLocale` change in the auth store, all components using `useDateFormatter` automatically re-render
4. **SSO Compatible**: When user logs in via SSO, the auth store updates, triggering re-renders with new timezone/locale

**Date Formatting Functions:**

```typescript
// src/client/common/utils/dateTime.ts

export function formatShortDate(
  date: string | Date | number | null | undefined,
  timezone: string = 'America/Sao_Paulo',
  locale: string = 'pt-BR'
): string {
  if (!date) return '-'

  try {
    const dateObj = typeof date === 'string' || typeof date === 'number'
      ? new Date(date)
      : date

    if (isNaN(dateObj.getTime())) return '-'

    // ‚úÖ Intl.DateTimeFormat automatically adapts format based on locale
    return new Intl.DateTimeFormat(locale, {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      timeZone: timezone
    }).format(dateObj)
  } catch (error) {
    console.warn('Failed to format date:', error)
    return '-'
  }
}

// Similar functions for:
// - formatLongDate (DD de MMM de YYYY vs MMM DD, YYYY)
// - formatTime (HH:mm vs h:mm A)
// - formatDateTime (DD/MM/YYYY HH:mm vs M/D/YYYY, h:mm A)
// - formatRelativeTime (h√° 2 horas vs 2 hours ago)
// - formatMonthYear (MMM YYYY)
```

**How Intl.DateTimeFormat Works:**

```javascript
// Brazil (pt-BR)
new Intl.DateTimeFormat('pt-BR', {
  day: '2-digit',
  month: '2-digit',
  year: 'numeric'
}).format(new Date('2025-01-10'))
// ‚Üí "10/01/2025" (DD/MM/YYYY)

// USA (en-US)
new Intl.DateTimeFormat('en-US', {
  day: '2-digit',
  month: '2-digit',
  year: 'numeric'
}).format(new Date('2025-01-10'))
// ‚Üí "01/10/2025" (MM/DD/YYYY)

// Note: Same options, different output based on locale!
```

### Phase 4: UI Internationalization (i18n)

**Translation Files Structure:**

```
src/client/common/i18n/
‚îú‚îÄ‚îÄ locales/
‚îÇ   ‚îú‚îÄ‚îÄ pt-BR/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common.json       (shared translations)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tq.json           (TQ app translations - 160+ keys)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ hub.json          (Hub app translations)
‚îÇ   ‚îî‚îÄ‚îÄ en-US/
‚îÇ       ‚îú‚îÄ‚îÄ common.json
‚îÇ       ‚îú‚îÄ‚îÄ tq.json           (TQ app translations - 160+ keys)
‚îÇ       ‚îî‚îÄ‚îÄ hub.json
‚îú‚îÄ‚îÄ i18n.ts                   (configuration)
‚îî‚îÄ‚îÄ languageDetector.ts       (custom detector)
```

**Translation File Example (TQ):**

```json
{
  "app_name": "TQ - Transcription Quote System",
  "common": {
    "created_at": "Created At",
    "updated_at": "Updated At",
    "save": "Save",
    "cancel": "Cancel",
    "loading": "Loading...",
    "error": "Error"
  },
  "patients": {
    "title": "Patients",
    "create": "Create Patient",
    "loading_patient": "Loading patient data...",
    "placeholders": {
      "first_name": "e.g., John",
      "email": "e.g., john.doe@example.com"
    }
  },
  "sessions": {
    "title": "Sessions",
    "loading_session": "Loading session data...",
    "placeholders": {
      "transcription": "Upload an audio file or start transcribing..."
    }
  }
  // ... 160+ total translation keys
}
```

**Custom Language Detector:**

```typescript
// src/client/common/i18n/languageDetector.ts

export const customLanguageDetector = {
  type: 'languageDetector',

  detect: () => {
    try {
      // Try TQ auth store first
      const { useAuthStore: useTQAuthStore } = require('@client/apps/tq/shared/store/auth')
      const locale = useTQAuthStore.getState().tenantLocale
      if (locale) return locale
    } catch (e) {
      // TQ store not available
    }

    try {
      // Try Hub auth store
      const { useAuthStore: useHubAuthStore } = require('@client/apps/hub/store/auth')
      const locale = useHubAuthStore.getState().tenantLocale
      if (locale) return locale
    } catch (e) {
      // Hub store not available
    }

    // Fallback
    return 'pt-BR'
  },

  init: () => {},
  cacheUserLanguage: () => {}
}
```

**Component Usage:**

```typescript
// Before (hardcoded):
<Input label="Created At" placeholder="e.g., John" />
<p>Loading patient data...</p>

// After (translated):
import { useTranslation } from 'react-i18next'

const { t } = useTranslation('tq')

<Input
  label={t('common.created_at')}
  placeholder={t('patients.placeholders.first_name')}
/>
<p>{t('patients.loading_patient')}</p>
```

---

## üîç Complete Problem-Solving Journey

This section documents all the issues encountered during implementation and their solutions, providing a complete reference for future debugging.

### Issue 1: Database Pool Not Using UTC

**Symptom:**
```sql
SELECT created_at FROM patient;
-- Result: 2025-10-09 20:24:48.503-03 (S√£o Paulo timezone)
-- Expected: Should be stored in UTC internally
```

**Root Cause:**
- PostgreSQL pool connections were being created without timezone configuration
- Each query from the pool inherited the server's default timezone (America/Sao_Paulo)
- The `SET TIME ZONE 'UTC'` in individual queries wasn't persistent across pool connections

**Initial Attempts (All Failed):**

```javascript
// ‚ùå Attempt 1: Setting timezone in middleware
async applyTenantSearchPath(schemaName, tenantTimezone) {
  await database.query(`SET LOCAL TIME ZONE 'UTC'`)  // Only affects current transaction
}

// ‚ùå Attempt 2: Setting timezone in provisioner
async function provisionTQAppSchema(client, schema) {
  await client.query(`SET LOCAL TIME ZONE 'UTC'`)  // Only affects provisioning transaction
}

// ‚ùå Attempt 3: Setting timezone in migration runner
async function runMigrations() {
  await database.query(`SET TIME ZONE 'UTC'`)  // Only affects migration connection
}
```

**Working Solution:**

```javascript
// ‚úÖ CORRECT: Configure ALL pool connections on connect event
// src/server/infra/db/database.js

class Database {
  constructor() {
    this.pool = new Pool(this.config)
    this.setupPoolEvents()  // NEW: Critical addition
  }

  setupPoolEvents() {
    // Force UTC timezone on EVERY connection from the pool
    this.pool.on('connect', async (client) => {
      try {
        await client.query("SET TIME ZONE 'UTC'")
        console.log('‚úÖ Database client connected with UTC timezone')
      } catch (error) {
        console.error('‚ùå Failed to set UTC timezone:', error)
      }
    })

    this.pool.on('error', (err) => {
      console.error('‚ùå Database pool error:', err)
    })
  }
}
```

**Verification:**
```sql
-- After fix, all new connections automatically use UTC
SHOW timezone;  -- Returns: UTC

-- Data stored correctly in UTC
SELECT created_at FROM patient;
-- 2025-10-10 03:26:14.093+00 (UTC)
```

### Issue 2: TIMESTAMP vs TIMESTAMPTZ Inconsistency

**Symptom:**
- `tenants` table showed timestamps with timezone offset: `2025-10-09 20:24:48-03`
- `users` table showed timestamps without timezone: `2025-10-09 20:24:48`
- Confusion about which was "correct"

**Root Cause:**
```sql
-- Migration had inconsistent column types
CREATE TABLE tenants (
  created_at TIMESTAMPTZ  -- ‚úÖ Stores timezone info
);

CREATE TABLE users (
  created_at TIMESTAMP  -- ‚ùå NO timezone info
);
```

**Understanding the Difference:**

```sql
-- TIMESTAMP (without time zone):
-- - Stores: 2025-10-09 20:24:48
-- - Interpretation: "Na√Øve" timestamp (no timezone info)
-- - Problem: Ambiguous! Is this S√£o Paulo time? Brisbane time? UTC?

-- TIMESTAMPTZ (with time zone):
-- - Stores internally: UTC timestamp
-- - Displays: Adjusted to session timezone (2025-10-09 20:24:48-03)
-- - Benefit: Unambiguous! Always knows exact moment in time
```

**Solution:**
```sql
-- Changed ALL timestamp columns to TIMESTAMPTZ
-- src/server/infra/migrations/001_create_core_tables.sql

CREATE TABLE tenants (
  created_at TIMESTAMPTZ DEFAULT (now() AT TIME ZONE 'UTC'),  -- ‚úÖ
  updated_at TIMESTAMPTZ DEFAULT (now() AT TIME ZONE 'UTC')   -- ‚úÖ
);

CREATE TABLE users (
  created_at TIMESTAMPTZ DEFAULT (now() AT TIME ZONE 'UTC'),  -- ‚úÖ Changed
  updated_at TIMESTAMPTZ DEFAULT (now() AT TIME ZONE 'UTC')   -- ‚úÖ Changed
);

-- Applied to ALL tables: tenants, users, tenant_applications,
-- user_application_access, application_access_logs, tenant_branding
```

**Result:**
```sql
-- Verify all columns are now TIMESTAMPTZ
SELECT
  column_name,
  data_type
FROM information_schema.columns
WHERE table_name IN ('tenants', 'users')
  AND column_name LIKE '%_at';

-- Expected output:
-- created_at | timestamp with time zone
-- updated_at | timestamp with time zone
```

### Issue 3: Locale Not Being Derived from Timezone

**Symptom:**
```javascript
// JWT payload showed wrong locale for Brazilian tenant
{
  timezone: "America/Sao_Paulo",
  locale: "en-US"  // ‚ùå Should be pt-BR
}
```

**Root Cause:**
```javascript
// src/shared/types/user.js (WRONG PATH)
const { getLocaleFromTimezone } = require('../server/infra/utils/localeMapping')
//                                         ^^^^^^^^
// File structure:
// src/
//   ‚îú‚îÄ‚îÄ shared/types/user.js  ‚Üê We are here
//   ‚îî‚îÄ‚îÄ server/infra/utils/localeMapping.js
//
// ../server/ goes UP one level then looks for server/ - doesn't exist!
// Should be: ../../server/
```

**Solution:**
```javascript
// src/shared/types/user.js (CORRECT PATH)
function createJwtPayload(user, tenant, allowedApps = [], userType = null) {
  let locale = 'en-US'
  if (tenant.timezone) {
    try {
      // ‚úÖ Correct relative path
      const { getLocaleFromTimezone } = require('../../server/infra/utils/localeMapping')
      locale = getLocaleFromTimezone(tenant.timezone)
      console.log(`[JWT] Derived locale '${locale}' from timezone '${tenant.timezone}'`)
    } catch (error) {
      console.warn('[JWT] Failed to derive locale:', error.message)
    }
  }

  return {
    // ... other fields
    timezone: tenant.timezone || 'America/Sao_Paulo',
    locale: locale  // ‚úÖ Now correctly pt-BR for Brazilian tenants
  }
}
```

**Verification:**
```javascript
// Backend console output after login:
[JWT] Derived locale 'pt-BR' from timezone 'America/Sao_Paulo'  // ‚úÖ

// JWT payload:
{
  timezone: "America/Sao_Paulo",
  locale: "pt-BR"  // ‚úÖ Correct!
}
```

### Issue 4: useDateFormatter Hook Not Reading Timezone

**Symptom:**
```javascript
// Console logs showed:
üîç [useDateFormatter] Store availability: {hasTQStore: false, hasHubStore: false}
üïê [useDateFormatter] Final values - timezone: America/Sao_Paulo locale: pt-BR

// Even for Australian tenant with:
{timezone: "Australia/Brisbane", locale: "en-US"}
```

**Root Cause:**
Dynamic `require()` inside React hook violated Rules of Hooks and failed silently.

```typescript
// ‚ùå BROKEN APPROACH
export function useDateFormatter() {
  let useTQAuthStore: any = null

  // This try/catch executes, but require() returns null
  try {
    const tqAuth = require('@client/apps/tq/shared/store/auth')
    useTQAuthStore = tqAuth.useAuthStore  // ‚ùå Always null in Vite/React
  } catch (e) {
    // Doesn't even throw - just returns null
  }

  // Condition always false, always uses fallback
  if (useTQAuthStore) {  // Never true
    timezone = useTQAuthStore(state => state.tenantTimezone)
  }

  // ‚ùå Result: Always defaults to 'America/Sao_Paulo'
  if (!timezone) timezone = 'America/Sao_Paulo'
}
```

**Why `require()` Failed:**
1. Vite (frontend bundler) doesn't support dynamic `require()` in ES modules
2. React expects hooks to be imported statically to track dependencies
3. `require()` inside function body returns `null` instead of throwing error
4. No error message - silent failure making it hard to debug

**Working Solution:**

```typescript
// ‚úÖ CORRECT: Static import at module level
// src/client/common/hooks/useDateFormatter.ts

import { useAuthStore as useTQAuthStore } from '@client/apps/tq/shared/store/auth'

export function useDateFormatter() {
  // ‚úÖ Unconditional Zustand hook call (follows Rules of Hooks)
  const timezone = useTQAuthStore(state => state.tenantTimezone) || 'America/Sao_Paulo'
  const locale = useTQAuthStore(state => state.tenantLocale) || 'pt-BR'

  // ‚úÖ Reactive: Re-renders when auth store changes
  return {
    formatShortDate: (date) => formatShortDateUtil(date, timezone, locale),
    // ... other formatters
  }
}
```

**Verification:**
```javascript
// Console output after fix:
üîç [useDateFormatter] Auth Store values: {
  timezone: "Australia/Brisbane",  // ‚úÖ Correct!
  locale: "en-US",                 // ‚úÖ Correct!
  tenantId: 3,
  isAuthenticated: true
}

// Dates now display correctly:
// Brazilian tenant: 14/10/2025, 22:26 (S√£o Paulo -3)
// Australian tenant: 10/15/2025, 11:30 (Brisbane +10)
```

### Issue 5: Browser Cache Preventing Updates

**Symptom:**
- Code changes not appearing in browser
- Console logs showing old version of code
- Hard refresh (Ctrl+Shift+R) not working

**Root Cause:**
- Vite dev server's Hot Module Replacement (HMR) caching aggressively
- Browser service workers caching JavaScript bundles
- LocalStorage persisting old auth data

**Solution:**
```bash
# 1. Kill and restart Vite dev server
npx kill-port 3005
npm run dev:tq-front

# 2. In browser DevTools ‚Üí Application tab:
# - Clear site data (all storage)
# - Disable cache checkbox in Network tab

# 3. Test in Incognito/Private mode (no cache)
# Chrome: Ctrl+Shift+N
# Firefox: Ctrl+Shift+P

# 4. Clear localStorage programmatically
localStorage.clear()
sessionStorage.clear()
location.reload()
```

**Prevention:**
- Add version comment in code to verify bundle updates
- Use Incognito mode for testing major changes
- Clear browser cache between tenant tests

---

## üß™ Testing & Verification

### Database UTC Verification

```sql
-- 1. Check PostgreSQL timezone
SHOW timezone;
-- Expected: UTC

-- 2. Check container timezone (if using Docker)
-- In terminal:
docker compose exec postgres date
-- Expected: UTC time

-- 3. Verify data is stored in UTC
SELECT
  timezone,
  created_at,
  created_at AT TIME ZONE 'UTC' AS stored_utc,
  created_at AT TIME ZONE timezone AS tenant_local
FROM tenants
CROSS JOIN patient
LIMIT 1;

-- Example result:
-- timezone          | created_at                    | stored_utc               | tenant_local
-- America/Sao_Paulo | 2025-10-10 00:26:14.093-03    | 2025-10-10 03:26:14.093  | 2025-10-10 00:26:14.093
--                                                     ‚Üë UTC (3h ahead)            ‚Üë Local time
```

### Locale Derivation Test

```javascript
// Check JWT payload after login
// Browser console or backend logs:

// Expected for Brazilian tenant:
{
  userId: 123,
  tenantId: 456,
  timezone: "America/Sao_Paulo",
  locale: "pt-BR"  // ‚úÖ Correctly derived
}

// Expected for Australian tenant:
{
  userId: 789,
  tenantId: 101,
  timezone: "Australia/Brisbane",
  locale: "en-US"  // ‚úÖ Correctly derived
}
```

### Frontend Display Test

```typescript
// In any TQ component:
const { formatShortDate, getTimezone, getLocale } = useDateFormatter()

console.log('Timezone:', getTimezone())
console.log('Locale:', getLocale())
console.log('Formatted:', formatShortDate('2025-01-10T12:00:00Z'))

// Brazilian tenant output:
// Timezone: America/Sao_Paulo
// Locale: pt-BR
// Formatted: 10/01/2025

// Australian tenant output:
// Timezone: Australia/Brisbane
// Locale: en-US
// Formatted: 1/10/2025
```

---

## üêõ Troubleshooting

### Issue 1: Data Not in UTC

**Symptom:**
```sql
SELECT created_at FROM patient;
-- Shows: 2025-10-09 20:24:48.503 -0300
-- Expected: Should be in UTC when session timezone is UTC
```

**Diagnosis:**
```sql
-- Check session timezone
SHOW timezone;
-- If not UTC, pool events aren't working

-- Check stored value
SELECT created_at AT TIME ZONE 'UTC' FROM patient;
-- If this differs from created_at by several hours, data IS in UTC (good!)
```

**Solution:**
- Verify `pool.on('connect')` is called in `database.js`
- Check Docker environment variables: `PGTZ=UTC` and `TZ=UTC`
- Restart PostgreSQL container and application

### Issue 2: Wrong Locale in JWT

**Symptom:**
```javascript
// JWT shows en-US for Brazilian tenant
{
  timezone: "America/Sao_Paulo",
  locale: "en-US"  // ‚ùå Wrong!
}
```

**Diagnosis:**
```javascript
// Check backend logs for:
[JWT] Failed to derive locale from timezone, using default en-US: Error: ...
// This means require() is failing
```

**Solution:**
- Check file path in `src/shared/types/user.js`
- Should be: `require('../../server/infra/utils/localeMapping')`
- NOT: `require('../server/infra/utils/localeMapping')`

### Issue 3: Dates Not Formatting

**Symptom:**
- All dates show as `-` (dash)
- Or dates show in wrong timezone

**Diagnosis:**
```typescript
// In component:
const { getTimezone, getLocale } = useDateFormatter()
console.log('TZ:', getTimezone(), 'Locale:', getLocale())

// If both undefined or wrong values:
// - Check if user is authenticated
// - Check if JWT has timezone/locale fields
// - Check auth store state
```

**Solution:**
1. Verify user is logged in
2. Check JWT payload contains `timezone` and `locale`
3. Verify auth store is populated: `useAuthStore.getState()`
4. Check browser console for i18n errors

### Issue 4: Translations Not Working

**Symptom:**
- UI still shows English for Brazilian tenant
- Or shows translation keys instead of text: `patients.loading_patient`

**Diagnosis:**
```typescript
// Check current language
import { useTranslation } from 'react-i18next'
const { i18n } = useTranslation()
console.log('Current language:', i18n.language)
console.log('Available languages:', i18n.languages)
```

**Solution:**
1. Verify translation files exist in `src/client/common/i18n/locales/`
2. Check `i18n.ts` configuration includes both `pt-BR` and `en-US`
3. Verify component imports: `useTranslation('tq')` not `useTranslation()`
4. Check translation key path: `t('patients.loading_patient')` matches JSON structure

---

## üìÅ Files Reference

### Backend Files

**Database Layer:**
```
src/server/infra/db/
‚îú‚îÄ‚îÄ database.js                    ‚úÖ Pool events (SET TIME ZONE 'UTC')
‚îî‚îÄ‚îÄ index.js

src/server/infra/provisioners/
‚îî‚îÄ‚îÄ tq.js                          ‚úÖ Removed SET LOCAL timezone
```

**Locale Mapping:**
```
src/server/infra/utils/
‚îî‚îÄ‚îÄ localeMapping.js               ‚úÖ getLocaleFromTimezone()
```

**JWT Payload:**
```
src/shared/types/
‚îî‚îÄ‚îÄ user.js                        ‚úÖ createJwtPayload() with locale derivation
```

**Docker:**
```
docker-compose.yml                 ‚úÖ PGTZ=UTC, TZ=UTC
```

### Frontend Files

**Date Formatting:**
```
src/client/common/hooks/
‚îî‚îÄ‚îÄ useDateFormatter.ts            ‚úÖ Main hook for all date formatting

src/client/common/utils/
‚îî‚îÄ‚îÄ dateTime.ts                    ‚úÖ Formatting functions (formatShortDate, etc.)
```

**Internationalization:**
```
src/client/common/i18n/
‚îú‚îÄ‚îÄ i18n.ts                        ‚úÖ i18n configuration
‚îú‚îÄ‚îÄ languageDetector.ts            ‚úÖ Custom language detector
‚îî‚îÄ‚îÄ locales/
    ‚îú‚îÄ‚îÄ pt-BR/
    ‚îÇ   ‚îú‚îÄ‚îÄ common.json
    ‚îÇ   ‚îú‚îÄ‚îÄ tq.json                ‚úÖ 160+ translations
    ‚îÇ   ‚îî‚îÄ‚îÄ hub.json
    ‚îî‚îÄ‚îÄ en-US/
        ‚îú‚îÄ‚îÄ common.json
        ‚îú‚îÄ‚îÄ tq.json                ‚úÖ 160+ translations
        ‚îî‚îÄ‚îÄ hub.json
```

**Components Updated (30 total):**

TQ App:
```
src/client/apps/tq/features/
‚îú‚îÄ‚îÄ home/Home.tsx                  ‚úÖ 7 sections translated
‚îú‚îÄ‚îÄ auth/Login.tsx                 ‚úÖ 2 placeholders
‚îú‚îÄ‚îÄ session/
‚îÇ   ‚îú‚îÄ‚îÄ NewSession.tsx             ‚úÖ 2 placeholders
‚îÇ   ‚îî‚îÄ‚îÄ EditSession.tsx            ‚úÖ loading/error/placeholders
‚îú‚îÄ‚îÄ patients/
‚îÇ   ‚îú‚îÄ‚îÄ CreatePatient.tsx          ‚úÖ all fields/placeholders
‚îÇ   ‚îî‚îÄ‚îÄ EditPatient.tsx            ‚úÖ all fields/loading/error
‚îú‚îÄ‚îÄ quotes/
‚îÇ   ‚îú‚îÄ‚îÄ EditQuote.tsx              ‚úÖ loading/error/Created At/Updated At
‚îÇ   ‚îú‚îÄ‚îÄ items/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateItem.tsx         ‚úÖ placeholders
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ EditItem.tsx           ‚úÖ loading/placeholders/Created At
‚îÇ   ‚îî‚îÄ‚îÄ QuoteItemsManager.tsx      ‚úÖ search placeholder
‚îú‚îÄ‚îÄ clinical-reports/
‚îÇ   ‚îî‚îÄ‚îÄ EditClinicalReport.tsx     ‚úÖ loading/error/Created At/placeholders
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îú‚îÄ‚îÄ CreateTemplate.tsx         ‚úÖ placeholders/validation
‚îÇ   ‚îî‚îÄ‚îÄ EditTemplate.tsx           ‚úÖ placeholders/validation
‚îî‚îÄ‚îÄ public-quotes/
    ‚îú‚îÄ‚îÄ EditPublicQuoteTemplate.tsx      ‚úÖ loading/placeholders/delete
    ‚îú‚îÄ‚îÄ CreatePublicQuoteTemplate.tsx    ‚úÖ placeholders
    ‚îú‚îÄ‚îÄ PublicQuoteAccess.tsx            ‚úÖ loading/password placeholder
    ‚îú‚îÄ‚îÄ PreviewPublicQuoteLink.tsx       ‚úÖ loading/error
    ‚îî‚îÄ‚îÄ PreviewPublicQuoteTemplate.tsx   ‚úÖ loading
```

---

## üíª Practical Usage Examples

### Example 1: Creating a New Component with Timezone-Aware Dates

```typescript
// src/client/apps/tq/components/sessions/SessionList.tsx

import { useDateFormatter } from '@client/common/hooks/useDateFormatter'
import { useTranslation } from 'react-i18next'

export const SessionList = ({ sessions }) => {
  const { formatShortDate, formatTime } = useDateFormatter()
  const { t } = useTranslation('tq')

  return (
    <div>
      <h2>{t('sessions.title')}</h2>
      {sessions.map(session => (
        <div key={session.id}>
          <p>{formatShortDate(session.createdAt)}</p>
          <p>{formatTime(session.createdAt)}</p>
        </div>
      ))}
    </div>
  )
}

// Output for Brazilian tenant (pt-BR, America/Sao_Paulo):
// ‚Üí 14/10/2025
// ‚Üí 22:26

// Output for Australian tenant (en-US, Australia/Brisbane):
// ‚Üí 10/15/2025
// ‚Üí 11:30 AM
```

### Example 2: Backend API Returning UTC Timestamps

```javascript
// src/server/api/tq/routes/patients.js

router.get('/', async (req, res) => {
  const patients = await Patient.findAll(req.tenant.schema)

  res.json({
    data: patients,  // Timestamps automatically in UTC
    meta: { total: patients.length }
  })
})

// Response (same for all tenants):
{
  "data": [{
    "id": 1,
    "name": "John Doe",
    "createdAt": "2025-10-15T01:30:11.686Z"  // ‚úÖ Always UTC (Z suffix)
  }]
}

// Frontend automatically converts to tenant timezone:
// Brazilian tenant sees: 14/10/2025, 22:30
// Australian tenant sees: 10/15/2025, 11:30
```

### Example 3: Creating a Multi-Tenant Report

```typescript
// Component that works for ANY tenant timezone
export const PatientReport = ({ patient }) => {
  const { formatLongDate, formatDateTime, getTimezone } = useDateFormatter()
  const { t } = useTranslation('tq')

  return (
    <div>
      <h1>{t('reports.patient_summary')}</h1>
      <p>
        {t('common.created_at')}: {formatLongDate(patient.createdAt)}
      </p>
      <p>
        {t('reports.last_visit')}: {formatDateTime(patient.lastVisit)}
      </p>
      <small>
        {t('reports.timezone')}: {getTimezone()}
      </small>
    </div>
  )
}

// Brazilian tenant output (pt-BR):
// Resumo do Paciente
// Criado em: 15 de outubro de 2025
// √öltima visita: 15/10/2025 11:30
// Fuso hor√°rio: America/Sao_Paulo

// Australian tenant output (en-US):
// Patient Summary
// Created At: October 15, 2025
// Last Visit: 10/15/2025, 11:30 AM
// Timezone: Australia/Brisbane
```

### Example 4: Debugging Timezone Issues

```typescript
// Add to any component to debug timezone
import { useDateFormatter } from '@client/common/hooks/useDateFormatter'
import { useAuthStore } from '@client/apps/tq/shared/store/auth'

export const DebugTimezone = () => {
  const { getTimezone, getLocale } = useDateFormatter()
  const authState = useAuthStore()

  console.table({
    'Hook Timezone': getTimezone(),
    'Hook Locale': getLocale(),
    'Store Timezone': authState.tenantTimezone,
    'Store Locale': authState.tenantLocale,
    'User Authenticated': authState.isAuthenticated,
    'Tenant ID': authState.tenantId
  })

  return null
}

// Console output:
// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
// ‚îÇ     (index)          ‚îÇ        Values          ‚îÇ
// ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
// ‚îÇ Hook Timezone        ‚îÇ 'Australia/Brisbane'   ‚îÇ
// ‚îÇ Hook Locale          ‚îÇ 'en-US'                ‚îÇ
// ‚îÇ Store Timezone       ‚îÇ 'Australia/Brisbane'   ‚îÇ
// ‚îÇ Store Locale         ‚îÇ 'en-US'                ‚îÇ
// ‚îÇ User Authenticated   ‚îÇ true                   ‚îÇ
// ‚îÇ Tenant ID            ‚îÇ 3                      ‚îÇ
// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìä Implementation Status

### ‚úÖ Completed (100%)

1. **Database Layer**
   - ‚úÖ All timestamps stored in UTC (TIMESTAMPTZ)
   - ‚úÖ Pool connections forced to UTC timezone via `pool.on('connect')`
   - ‚úÖ Docker PostgreSQL configured with UTC (`PGTZ=UTC`, `TZ=UTC`)
   - ‚úÖ Changed all `TIMESTAMP` to `TIMESTAMPTZ` in migrations
   - ‚úÖ Verification queries documented and tested

2. **Backend Layer**
   - ‚úÖ Locale derivation from timezone (`localeMapping.js`)
   - ‚úÖ JWT payload includes timezone + locale
   - ‚úÖ Fixed require path in `user.js` (`../../server/infra/utils/localeMapping`)
   - ‚úÖ Timezone fetched from database when generating JWT
   - ‚úÖ Backend always returns ISO 8601 UTC timestamps

3. **Frontend Date Formatting**
   - ‚úÖ `useDateFormatter` hook with static import (follows Rules of Hooks)
   - ‚úÖ All date formatting functions implemented (`dateTime.ts`)
   - ‚úÖ Intl.DateTimeFormat with timezone + locale parameters
   - ‚úÖ Reactive to auth store changes (SSO compatible)
   - ‚úÖ 23 components migrated to use timezone-aware formatters

4. **Frontend i18n**
   - ‚úÖ Translation files (pt-BR + en-US) - 160+ keys each
   - ‚úÖ Custom language detector reading from auth store
   - ‚úÖ 30+ components fully translated
   - ‚úÖ All forms, placeholders, loading states, error messages

5. **Testing & Verification**
   - ‚úÖ End-to-end test with Brazilian tenant (S√£o Paulo -3)
   - ‚úÖ End-to-end test with Australian tenant (Brisbane +10)
   - ‚úÖ Verified dates display correctly in both timezones
   - ‚úÖ Verified UI translations work for both languages
   - ‚úÖ Screenshot evidence of working implementation

6. **Documentation**
   - ‚úÖ Consolidated documentation (this file)
   - ‚úÖ Complete problem-solving journey documented
   - ‚úÖ All 5 major issues and solutions documented
   - ‚úÖ Practical usage examples
   - ‚úÖ Troubleshooting guide
   - ‚úÖ Files reference with exact locations

---

## üéØ Summary

### What We Built

A complete timezone and internationalization system that:

1. **Stores all data in UTC** (PostgreSQL TIMESTAMPTZ)
2. **Automatically derives locale from timezone** (Brazil ‚Üí pt-BR, Others ‚Üí en-US)
3. **Formats dates correctly** per tenant's timezone and language
4. **Translates entire UI** based on tenant locale (160+ translation keys)
5. **Works seamlessly** across TQ and Hub applications

### Key Benefits

- ‚úÖ **Data Integrity**: No timezone ambiguity, all timestamps in UTC
- ‚úÖ **Automatic Language**: No manual language selection needed
- ‚úÖ **Consistent UX**: Same date format rules everywhere
- ‚úÖ **Scalable**: Easy to add new timezones (just update localeMapping.js)
- ‚úÖ **Maintainable**: Centralized formatting (useDateFormatter hook)

### Technical Highlights

- **Single Source of Truth**: JWT contains timezone + locale
- **Smart Defaults**: Falls back gracefully if data missing
- **Performance**: No extra API calls, data comes from JWT
- **Type Safety**: TypeScript for all frontend code
- **Best Practices**: Uses standard Intl.DateTimeFormat API

---

## üìÇ Complete Files Modified

### Critical Backend Changes

**Database Configuration:**
```
src/server/infra/db/database.js
  ‚úÖ Added setupPoolEvents() method
  ‚úÖ pool.on('connect') forces UTC timezone on all connections
```

**Migrations:**
```
src/server/infra/migrations/001_create_core_tables.sql
  ‚úÖ Changed ALL TIMESTAMP to TIMESTAMPTZ
  ‚úÖ Changed defaults to (now() AT TIME ZONE 'UTC')
  ‚úÖ Applied to: tenants, users, tenant_applications, user_application_access,
     application_access_logs, tenant_branding
```

**Locale Mapping:**
```
src/server/infra/utils/localeMapping.js
  ‚úÖ getLocaleFromTimezone() - Maps 16 Brazil timezones ‚Üí pt-BR, others ‚Üí en-US
  ‚úÖ getLanguageFromLocale() - Extracts language code (pt-BR ‚Üí pt)
  ‚úÖ isSupportedTimezone() - Validates IANA timezone strings
  ‚úÖ getLocaleMetadata() - Returns currency, date format metadata
```

**JWT Payload:**
```
src/shared/types/user.js
  ‚úÖ Fixed require path: require('../../server/infra/utils/localeMapping')
  ‚úÖ createJwtPayload() derives locale from timezone
  ‚úÖ JWT includes: timezone (IANA string), locale (pt-BR or en-US)
```

**Auth Service:**
```
src/server/infra/authService.js
  ‚úÖ login() fetches tenant timezone from database
  ‚úÖ register() includes timezone in JWT
  ‚úÖ refreshToken() re-fetches fresh timezone
```

### Critical Frontend Changes

**Date Formatting Hook:**
```
src/client/common/hooks/useDateFormatter.ts
  ‚úÖ Static import: import { useAuthStore } from '@client/apps/tq/shared/store/auth'
  ‚úÖ Reactive Zustand subscription (follows Rules of Hooks)
  ‚úÖ Returns 7 formatting functions + timezone/locale getters
  ‚úÖ Re-renders when auth store timezone/locale change
```

**Date Utilities:**
```
src/client/common/utils/dateTime.ts
  ‚úÖ formatShortDate() - DD/MM/YYYY or M/D/YYYY based on locale
  ‚úÖ formatLongDate() - Full month name format
  ‚úÖ formatTime() - 24h (pt-BR) vs 12h AM/PM (en-US)
  ‚úÖ formatDateTime() - Combined date + time
  ‚úÖ formatRelativeTime() - "h√° 2 horas" vs "2 hours ago"
  ‚úÖ formatMonthYear() - MMM YYYY
  ‚úÖ getNowInTimezone() - Current date in tenant timezone
```

**Auth Stores:**
```
src/client/apps/tq/shared/store/auth.ts
  ‚úÖ Added tenantTimezone field (IANA string)
  ‚úÖ Added tenantLocale field (pt-BR or en-US)
  ‚úÖ loginWithToken() extracts from JWT payload
  ‚úÖ Persists to localStorage via Zustand middleware

src/client/apps/hub/store/auth.ts
  ‚úÖ Same fields added for Hub app
  ‚úÖ Same JWT extraction logic
```

**i18n Configuration:**
```
src/client/common/i18n/i18n.ts
  ‚úÖ Configured react-i18next with pt-BR and en-US
  ‚úÖ Custom language detector reads from auth store
  ‚úÖ Fallback language: en-US

src/client/common/i18n/locales/pt-BR/tq.json
src/client/common/i18n/locales/en-US/tq.json
  ‚úÖ 160+ translation keys per language
  ‚úÖ Covers: common, patients, sessions, quotes, clinical reports, templates, etc.
```

**Components Updated (23 total):**
```
src/client/apps/tq/features/home/Home.tsx - ‚úÖ 7 date formats migrated
src/client/apps/tq/features/quotes/EditQuote.tsx - ‚úÖ formatDateTime
src/client/apps/tq/features/patients/PatientHistory.tsx - ‚úÖ 7 formatShortDate
src/client/apps/tq/features/clinical-reports/ViewClinicalReport.tsx - ‚úÖ formatLongDate
src/client/apps/tq/features/clinical-reports/EditClinicalReport.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/patients/PatientRow.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/session/SessionRow.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/clinical-reports/ClinicalReportRow.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/items/ItemRow.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/templates/TemplateRow.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/public-quotes/PublicQuoteLinkRow.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/quotes/QuoteRow.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/quotes/GeneratePublicQuoteModal.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/home/QuoteCard.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/home/ReportCard.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/home/SessionCard.tsx - ‚úÖ formatShortDate
src/client/apps/tq/components/home/RecentPatientRow.tsx - ‚úÖ formatShortDate
src/client/apps/tq/services/quotes.ts - ‚úÖ formatDate helper
src/client/apps/tq/services/sessions.ts - ‚úÖ formatDate helper
src/client/apps/tq/services/patients.ts - ‚úÖ formatDate helper
src/client/apps/hub/features/entitlements/EntitlementsSummaryCard.tsx - ‚úÖ formatShortDate
src/client/apps/hub/features/entitlements/EntitlementAppCard.tsx - ‚úÖ formatShortDate
src/server/services/templateVariableResolver.js - ‚úÖ Date resolution for AI Agent
```

### Docker Configuration

```
docker-compose.yml
  ‚úÖ PGTZ: UTC - PostgreSQL server timezone
  ‚úÖ TZ: UTC - Container timezone
```

---

## üéì Key Learnings

1. **PostgreSQL Pool Events**: Connection-level settings require `pool.on('connect')` - transaction-level `SET LOCAL` doesn't persist
2. **TIMESTAMPTZ vs TIMESTAMP**: Always use TIMESTAMPTZ for unambiguous timestamps - stores internally in UTC, displays in session timezone
3. **React Rules of Hooks**: Dynamic `require()` inside hooks violates React rules - use static imports
4. **Vite Module System**: Vite doesn't support dynamic `require()` in ES modules - returns `null` instead of throwing
5. **Zustand Reactivity**: Use selector pattern `useStore(state => state.field)` for reactive subscriptions
6. **Intl.DateTimeFormat**: Native API adapts format automatically based on locale (DD/MM/YYYY vs MM/DD/YYYY)
7. **Browser Caching**: Vite HMR + Service Workers = aggressive caching - test in Incognito mode
8. **JWT as Transport**: Include derived data (locale) in JWT to avoid extra API calls
9. **Two Languages Only**: Business requirement simplified architecture (Brazil ‚Üí pt-BR, rest ‚Üí en-US)
10. **UTC Everywhere**: Store UTC, display in local timezone - never store local timestamps

---

## üîÄ Why Different Approaches for Locale Detection?

### The Question: Why Not Use the Same Approach Everywhere?

You might notice that we use **three different approaches** to read the tenant locale:

1. **useDateFormatter** ‚Üí Zustand Store (static import)
2. **useCurrencyFormatter** ‚Üí localStorage (useSyncExternalStore)
3. **i18n languageDetector** ‚Üí localStorage (direct read)

**This is intentional and necessary.** Here's why each approach is correct for its use case:

---

### 1Ô∏è‚É£ useDateFormatter - Zustand Store (TQ-Specific)

```typescript
// src/client/common/hooks/useDateFormatter.ts
import { useAuthStore as useTQAuthStore } from '@client/apps/tq/shared/store/auth'

export function useDateFormatter() {
  const timezone = useTQAuthStore(state => state.tenantTimezone) || 'America/Sao_Paulo'
  const locale = useTQAuthStore(state => state.tenantLocale) || 'pt-BR'
  // ...
}
```

**Why This Approach:**
- ‚úÖ **Fully Reactive**: Automatically re-renders when timezone/locale change in auth store
- ‚úÖ **Clean Code**: Simple selector pattern, no boilerplate
- ‚úÖ **Type Safe**: TypeScript knows the exact store shape
- ‚úÖ **Follows React Rules**: Static import, unconditional hook call

**Trade-off:**
- ‚ö†Ô∏è **TQ-Specific**: Directly imports from `@client/apps/tq/shared/store/auth`
- ‚ö†Ô∏è **Not Portable**: Doesn't work in Hub without modification

**Why This is OK:**
- The hook is **only used in TQ components** (23 components migrated)
- TQ has its own dedicated codebase (`src/client/apps/tq/`)
- No need for multi-app compatibility

---

### 2Ô∏è‚É£ useCurrencyFormatter - localStorage (Multi-App)

```typescript
// src/client/common/hooks/useCurrencyFormatter.ts
export function useCurrencyFormatter() {
  const tenantLocale = useSyncExternalStore(
    (callback) => {
      window.addEventListener('storage', callback)
      return () => window.removeEventListener('storage', callback)
    },
    () => {
      const authStorage = localStorage.getItem('auth-storage')
      if (authStorage) {
        const parsed = JSON.parse(authStorage)
        return parsed.state?.tenantLocale || null
      }
      return null
    },
    () => null
  )
  // ...
}
```

**Why This Approach:**
- ‚úÖ **Multi-App Compatible**: Works in TQ **AND** Hub without app-specific imports
- ‚úÖ **Fully Reactive**: `useSyncExternalStore` triggers re-renders on localStorage changes
- ‚úÖ **No App Coupling**: Doesn't depend on `@client/apps/tq/` or `@client/apps/hub/`
- ‚úÖ **Single Source of Truth**: Reads directly from Zustand's persisted state

**Trade-off:**
- ‚ö†Ô∏è **More Verbose**: Requires `useSyncExternalStore` boilerplate
- ‚ö†Ô∏è **Less Type Safe**: JSON parsing without strict types

**Why This is Necessary:**
- The hook is used in **common components** (`src/client/common/ui/PriceInput.tsx`)
- PriceInput is used in **both TQ and Hub apps**
- Cannot import TQ-specific auth store in common code
- localStorage is the **only** neutral data source accessible from common code

**Alternative Rejected:**
```typescript
// ‚ùå DOESN'T WORK - Would break in Hub
import { useAuthStore as useTQAuthStore } from '@client/apps/tq/shared/store/auth'
const locale = useTQAuthStore(state => state.tenantLocale)  // Hub can't import TQ store!
```

---

### 3Ô∏è‚É£ i18n languageDetector - localStorage (Pre-React)

```typescript
// src/client/common/i18n/config.ts
const languageDetector = new LanguageDetector()
languageDetector.addDetector({
  name: 'customDetector',
  lookup() {
    try {
      const authData = localStorage.getItem('auth-storage')
      if (authData) {
        const parsed = JSON.parse(authData)
        const locale = parsed?.state?.tenantLocale
        if (locale === 'pt-BR') return 'pt-BR'
      }
    } catch (error) {
      console.warn('Failed to detect language:', error)
    }
    return 'en-US'
  }
})
```

**Why This Approach:**
- ‚úÖ **Pre-React Initialization**: Executes **before** React mounts
- ‚úÖ **Not a React Component**: `lookup()` is a plain JavaScript function
- ‚úÖ **Multi-App Compatible**: Works in TQ and Hub
- ‚úÖ **No Dependencies**: Doesn't need React hooks or Zustand

**Trade-off:**
- ‚ö†Ô∏è **Not Reactive**: Only detects language once at initialization
- ‚ö†Ô∏è **Manual Updates**: Apps must call `i18n.changeLanguage()` when locale changes

**Why This is Necessary:**
- **i18n initializes globally** as a singleton before React renders
- Cannot use React hooks (`useAuthStore`) outside of React components
- `lookup()` function cannot be a React component or use hooks

**Reactivity Handled Separately:**
```typescript
// src/client/apps/tq/App.tsx
useEffect(() => {
  if (tenantLocale && i18n.language !== tenantLocale) {
    i18n.changeLanguage(tenantLocale)
  }
}, [tenantLocale])
```

**Alternative Rejected:**
```typescript
// ‚ùå DOESN'T WORK - React hooks can't run before React
import { useAuthStore } from '@client/apps/tq/shared/store/auth'
languageDetector.addDetector({
  lookup() {
    const locale = useAuthStore(state => state.tenantLocale)  // ‚ùå Not a component!
  }
})
```

---

## üìä Decision Matrix: Which Approach When?

| Use Case | Approach | Reason |
|---|---|---|
| **App-specific hook** (TQ only) | Zustand Store | ‚úÖ Clean, reactive, type-safe |
| **Common component** (TQ + Hub) | localStorage | ‚úÖ Multi-app compatible |
| **Pre-React initialization** | localStorage | ‚úÖ No React available yet |
| **Inside React component** | Prefer Zustand | ‚úÖ More idiomatic React |
| **Outside React component** | localStorage only | ‚úÖ No hooks available |

---

## üö´ What We DON'T Do (Anti-Patterns)

### ‚ùå Anti-Pattern 1: Dynamic require() in Hooks
```typescript
// ‚ùå WRONG - Violates Rules of Hooks
export function useDateFormatter() {
  let store = null
  try {
    const { useAuthStore } = require('@client/apps/tq/shared/store/auth')
    store = useAuthStore  // ‚ùå Returns null in Vite
  } catch (e) {}

  const locale = store ? store(state => state.tenantLocale) : 'pt-BR'
}
```

**Why Wrong:**
- Vite doesn't support dynamic `require()` - returns `null` silently
- Violates React Rules of Hooks (conditional hook call)
- Not reactive - doesn't update when locale changes

---

### ‚ùå Anti-Pattern 2: Import TQ Store in Common Code
```typescript
// ‚ùå WRONG - Breaks Hub app
// src/client/common/ui/PriceInput.tsx
import { useAuthStore } from '@client/apps/tq/shared/store/auth'  // ‚ùå TQ-specific!

export const PriceInput = () => {
  const locale = useAuthStore(state => state.tenantLocale)  // ‚ùå Undefined in Hub!
}
```

**Why Wrong:**
- PriceInput is used in Hub, which doesn't have `@client/apps/tq/`
- Creates tight coupling between common components and specific apps
- Breaks separation of concerns

---

### ‚ùå Anti-Pattern 3: Use React Hooks in i18n Config
```typescript
// ‚ùå WRONG - i18n initializes before React
import { useAuthStore } from '@client/apps/tq/shared/store/auth'

i18n.init({
  lng: useAuthStore(state => state.tenantLocale)  // ‚ùå Not a component!
})
```

**Why Wrong:**
- i18n config runs at module load time (before React)
- Can't use React hooks outside components
- Would throw: "Hooks can only be called inside a function component"

---

## ‚úÖ Summary: Why Different Approaches Are Correct

**The diversity of approaches is not a bug - it's a feature.** Each approach is optimized for its specific constraints:

1. **useDateFormatter (Zustand)** ‚Üí App-specific, reactive, clean
2. **useCurrencyFormatter (localStorage)** ‚Üí Multi-app, reactive, portable
3. **i18n (localStorage)** ‚Üí Pre-React, non-reactive, universal

**Attempting to "unify" these approaches would:**
- ‚ùå Break multi-app compatibility (Hub can't import TQ store)
- ‚ùå Break pre-React initialization (i18n can't use hooks)
- ‚ùå Add unnecessary complexity (dynamic imports, conditional logic)

**The current solution is the correct architectural choice given the constraints.**

---

**Implementation Complete!** üéâ

For questions or issues, refer to the [Complete Problem-Solving Journey](#-complete-problem-solving-journey) section or check the [Files Reference](#files-reference).
